// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`candles daemon sql test calculate and insert all candles from other small candles 1`] = `"insert into \\"candles\\" select to_timestamp(floor((extract('epoch' from time_start) / 300 )) * 300) as \\"candle_time\\", \\"amount_asset_id\\" as \\"amount_asset_id\\", \\"price_asset_id\\" as \\"price_asset_id\\", (select min(\\"low\\")) as \\"low\\", (select max(\\"high\\")) as \\"high\\", (select sum(\\"volume\\")) as \\"volume\\", (select sum(\\"quote_volume\\")) as \\"quote_volume\\", (select max(\\"max_height\\")) as \\"max_height\\", (select sum(\\"txs_count\\")) as \\"txs_count\\", floor(sum((weighted_average_price * volume)::numeric)::numeric / sum(volume)::numeric)::numeric as \\"weighted_average_price\\", (array_agg(open ORDER BY time_start)::numeric[])[1] as \\"open\\", (array_agg(close ORDER BY time_start DESC)::numeric[])[1] as \\"close\\", '5m' as \\"interval\\", \\"matcher_address\\" as \\"matcher_address\\" from \\"candles\\" as \\"t\\" where \\"t\\".\\"interval\\" = '1m' group by \\"candle_time\\", \\"amount_asset_id\\", \\"price_asset_id\\", \\"matcher_address\\""`;

exports[`candles daemon sql test get last candle height 1`] = `"select \\"max_height\\" from \\"candles\\" as \\"t\\" order by \\"max_height\\" desc limit 1"`;

exports[`candles daemon sql test get last exchange tx height 1`] = `"select \\"height\\" from \\"txs_7\\" as \\"t\\" order by \\"uid\\" desc limit 1"`;

exports[`candles daemon sql test insert all candles group by 1 minute 1`] = `"insert into \\"candles\\" with \\"e_cte\\" as (select \\"t\\".\\"uid\\" as \\"uid\\", \\"t\\".\\"amount_asset_id\\" as \\"amount_asset_id\\", \\"t\\".\\"price_asset_id\\" as \\"price_asset_id\\", \\"t\\".\\"sender\\" as \\"sender\\", \\"t\\".\\"height\\" as \\"height\\", date_trunc('minute', t.time_stamp) as \\"candle_time\\", \\"t\\".\\"amount\\" as \\"amount\\", \\"t\\".\\"price\\" as \\"price\\" from \\"txs_7\\" as \\"t\\") select \\"e\\".\\"candle_time\\" as \\"time_start\\", \\"amount_asset_id\\" as \\"amount_asset_id\\", \\"price_asset_id\\" as \\"price_asset_id\\", (select min(\\"e\\".\\"price\\")) as \\"low\\", (select max(\\"e\\".\\"price\\")) as \\"high\\", (select sum(\\"e\\".\\"amount\\")) as \\"volume\\", sum((e.amount)::numeric * (e.price)::numeric) as \\"quote_volume\\", (select max(\\"height\\")) as \\"max_height\\", (select count(\\"e\\".\\"price\\")) as \\"txs_count\\", floor(sum((e.amount)::numeric * (e.price)::numeric)/sum((e.amount)::numeric))::numeric as \\"weighted_average_price\\", (array_agg(e.price ORDER BY e.uid)::numeric[])[1] as \\"open\\", (array_agg(e.price ORDER BY e.uid DESC)::numeric[])[1] as \\"close\\", '1m' as \\"interval\\", \\"e\\".\\"sender\\" as \\"matcher_address\\" from \\"e_cte\\" as \\"e\\" group by e.candle_time, e.amount_asset_id, e.price_asset_id, e.sender"`;

exports[`candles daemon sql test insert or update array of candles 1`] = `"insert into \\"candles\\" as \\"t\\" (\\"amount_asset_id\\", \\"close\\", \\"high\\", \\"interval\\", \\"low\\", \\"matcher_address\\", \\"max_height\\", \\"open\\", \\"price_asset_id\\", \\"quote_volume\\", \\"time_start\\", \\"txs_count\\", \\"volume\\", \\"weighted_average_price\\") values ('aai', '80', '100', '1m', '1', DEFAULT, DEFAULT, '20', 'pai', '100.2', '1970-01-01T00:00:00.000Z', '22', '200.2', '2.1') on conflict (time_start, amount_asset_id, price_asset_id, matcher_address, interval) do update set open=EXCLUDED.open, close=EXCLUDED.close, low=EXCLUDED.low, high=EXCLUDED.high, max_height=EXCLUDED.max_height, quote_volume=EXCLUDED.quote_volume, txs_count=EXCLUDED.txs_count, volume=EXCLUDED.volume, weighted_average_price=EXCLUDED.weighted_average_price"`;

exports[`candles daemon sql test insert or update candles empty 1`] = `";"`;

exports[`candles daemon sql test insert or update candles from height 1`] = `"insert into \\"candles\\" select to_timestamp(floor((extract('epoch' from time_start) / 300 )) * 300) as \\"candle_time\\", \\"amount_asset_id\\" as \\"amount_asset_id\\", \\"price_asset_id\\" as \\"price_asset_id\\", (select min(\\"low\\")) as \\"low\\", (select max(\\"high\\")) as \\"high\\", (select sum(\\"volume\\")) as \\"volume\\", (select sum(\\"quote_volume\\")) as \\"quote_volume\\", (select max(\\"max_height\\")) as \\"max_height\\", (select sum(\\"txs_count\\")) as \\"txs_count\\", floor(sum((weighted_average_price * volume)::numeric)::numeric / sum(volume)::numeric)::numeric as \\"weighted_average_price\\", (array_agg(open ORDER BY time_start)::numeric[])[1] as \\"open\\", (array_agg(close ORDER BY time_start DESC)::numeric[])[1] as \\"close\\", '5m' as \\"interval\\", \\"matcher_address\\" as \\"matcher_address\\" from \\"candles\\" where \\"interval\\" = '1m' and time_start >= to_timestamp(floor((extract('epoch' from '2019-01-01T00:00:00.000Z'::timestamptz) / 300 )) * 300) group by \\"candle_time\\", \\"amount_asset_id\\", \\"price_asset_id\\", \\"matcher_address\\" on conflict (time_start, amount_asset_id, price_asset_id, matcher_address, interval) do update set open=EXCLUDED.open, close=EXCLUDED.close, low=EXCLUDED.low, high=EXCLUDED.high, max_height=EXCLUDED.max_height, quote_volume=EXCLUDED.quote_volume, txs_count=EXCLUDED.txs_count, volume=EXCLUDED.volume, weighted_average_price=EXCLUDED.weighted_average_price"`;

exports[`candles daemon sql test truncate table 1`] = `"truncate \\"candles\\" restart identity"`;
